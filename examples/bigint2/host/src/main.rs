// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use k256::ecdsa::{signature::Signer, Signature, SigningKey, VerifyingKey};
use methods::METHOD_ELF;
use rand_core::OsRng;
use risc0_zkvm::{
    default_prover, get_prover_server, ApiClient, Asset, AssetRequest, ProverOpts, VerifierContext,
};
use risc0_zkvm::{ExecutorEnv, ExecutorImpl};

fn generate_input(rounds: u32) -> Vec<(Vec<u8>, Signature, VerifyingKey)> {
    let signing_key = SigningKey::random(&mut OsRng);
    let mut res = vec![];
    for i in 0..rounds {
        let message = format!("this is the messge: {i}");
        let message = message.as_bytes();
        let signature: Signature = signing_key.sign(message);
        let verifying_key = VerifyingKey::from(&signing_key);
        res.push((message.to_vec(), signature, verifying_key));
    }

    res
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let input = generate_input(100);

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .segment_limit_po2(21)
        .build()
        .unwrap();

    // let prover = default_prover();
    // let _prove_info = prover.prove(env, METHOD_ELF).unwrap();

    let mut exec = ExecutorImpl::from_elf(env, METHOD_ELF).unwrap();
    let session = exec.run().unwrap();
    // session.prove().unwrap();

    // let client = ApiClient::new_sub_process("/home/ec2-user/r0vm1.2").unwrap();

    let opts = ProverOpts::default();
    let prover = get_prover_server(&opts).unwrap();
    let vctx = VerifierContext::default();

    let mut idx = 0;
    for segment_ref in session.segments {
        // let segment_vec = bincode::serialize(&segment).unwrap();
        // let segment_asset = Asset::Inline(segment_vec.into());
        // client
        //     .prove_segment(&opts, segment_asset, AssetRequest::Inline)
        //     .unwrap();

        if idx == 1 {
            let segment = segment_ref.resolve().unwrap();
            let start = std::time::Instant::now();
            prover.prove_segment(&vctx, &segment).unwrap();

            tracing::info!(
                "Segment {} prove time: {:?}",
                segment.index,
                start.elapsed()
            );
        }
        idx += 1;
    }
}
